# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <rawcell>

# 1. Computer science
# 1. Опишите различия static и dynamic typing.
# 2. Что такое SOLID принципы? Вспомните примеры нарушения каждого из них из
# своей практики.
# 3. Что такое инвариант класса? Как его можно использовать, чтобы избежать
# ненужных операторов if?
# 4. Что произойдет, если докажут равенство P=NP?
# 5. Для чего используются исключения?
# 6. Нужно ли уметь реализовывать структуры данных типа дерева, например,
# самостоятельно?
# 7. Как можно работать с общими данными в нескольких потоках выполнения? Какие
# способы синхронизации вы можете назвать?
# 8. Что такое race condition и почему он может возникать?
# 9. Что такое акторная модель и для чего ее имеет смысл использовать?
# 2. Объектно­ориентированное программирование
# 1. Что такое IoC? Для чего его можно и нужно использовать?
# 2. Что такое таблица виртуальных функций?
# 3. Что такое наследование, основанное на прототипах? Какие языки его используют?
# Сравните преимущества и недостатки наследования, основанного на прототипах, с
# традиционным вариантом, принятым, например, в Java.
# 4. Что такое контракт метода? Что в него входит?
# 5. Что такое контракт класса? Что в него входит?
# 3. Web
# 1. Опишите различия между GET и POST запросами.
# 2. Что такое cookie? Какие есть ограничение на размер, содержимое и доступ к
# cookie?
# 3. Чем отличаются механизмы взаимодействия клиента и сервера при помощи AJAX
# и с использованием WebSocket?
# 4. Как вы понимаете термин UX (User eXperience)? Чем он отличается от UI (User
# Interface)?
# 4. Persistance
# 1. Зачем нужны транзакции? Расшифруйте аббревиатуру ACID. Как вы понимаете
# каждую составляющую?
# 2. Какие бываю уровни изоляции транзакций? Как можно добиться согласованного
# изменения данных несколькими пользователями?
# 3. Расшифруйте аббревиатуру CRUD. Какие ключевые слова в SQL используются
# для описания функционала соответствующему каждому пункту данного
# определения?
# 4. Что такое ORM? Опишите плюсы и минусы использования ORM для доступа к БД
# 5. Как вы думаете, в чем основное преимущество NoSQL решений над SQL? А в чем
# недостатки?
# 6. Как вы понимаете суть CAP теоремы? Как вы думаете какими из свойств обладает
# социальная сеть Вконтакте в общем случае?
# 5. Практические навыки
# 1. Что такое система контроля версий? Нужно ли использовать ее, если пишешь код
# один?
# 2. Перечислите основные общепринятые рекомендации для названий переменных,
# классов, функций и методов, не зависящие от языка программирования.
# 3. Что такое самодокументируемый код? Когда имеет смысл писать комментарии в
# коде, а когда нет?
# 6. Тестирование и контроль качества
# 1. Что такое Test case? Кто обычно их составляет?
# 2. Что такое регрессионное тестирование?
# 3. Что такое unit­тестирование? Какие основные требования налагаются на
# реализацию unit­тестов?
# 4. Что такое Mock­объекты? Для чего их имеет смысл использовать?
# 5. Что такое Continuous Integration? Какие инструменты используются для реализации
# этого подхода?
# 6. Какие уязвимости бывают с веб­приложениях? Как можно их искать?
# 7. Что такое DoS­атака? Какие есть способы защиты от нее? Как это связано с
# ботнетами?

# <rawcell>

# 1. Computer science
# 
# 1. Опишите различия static и dynamic typing.
# Статическая и динамическая типизация. В языках программирования со статической типизацией данных тип переменной присваивается в момент компиляции программы, далее эта переменная может использовать только данные определенного типа. При динамической типизации тип переменной присваивается в момент присваивания переменной значения.
# 
# Пример динамической типизации(python):

# <codecell>

a = 1
print (type(a))
a = 2.5
print (type(a))
a = ' Hellow world'
print (type(a))

# <rawcell>

# 2. Что такое SOLID принципы? Вспомните примеры нарушения каждого из них из
# своей практики.
# Solid принципы ооп применяются, для того чтобы понизить количество логических ошибок, для удобной поддержки и последующего расширения проекта.
# Принцип единственной ответственности (Single responsibility)
# Каждый объект должен должен иметь свою обязанность. Если объект будет использоваться для разных целей, то при изменении нужно будет учитывать все его обязанности.
# К примеру функция multiplication_and_division (int a,b) умножает и делит числа от 1 до 99, но если добавить в набор 0, функция деления перестанет работать, в то время как умножение работает, нужно как-то править код, хотя для умножения его править не нужно.
# Когда я делал программу по распаковке игровых файлов, я добавил в функцию распаковки переименование файлов. В итоге когда мне позже
# начали попадаться нестандартные файлы мне приходилось переименовывать их в ручную.
# 
# Принцип открытости/закрытости (Open-closed)
# Классы должны быть открыты для расширения, но закрыты для изменения, для того чтобы добавить функционал нам не нужно было изменять базовый класс, а унаследовать от него новый класс с расширенным функционалом. К примеру у нас есть класс printer который выводит что-то на экран с помощью функции printOut и теперь нам нужно добавить функционал чтобы можно было писать в файл. 
# Мы наследуем от printer класс printerFile и добавляем метод printFile для того чтобы она выводила информацию в файл.
# Для того чтобы решить проблемы из предыдущего ответа я вместо того чтобы разделить функционал написал ещё несколько классов которые обрабатывают различные нестандартные файлы (количество кода увеличилось раза в 3). Правильно нужно было создать 2 класса:
# распаковщик и переименовщик. Для обработки нестандартных файлов нужно было наследоваться от переименовщика и дополнять функционал.
# 
# Принцип подстановки Барбары Лисков (Liskov substitution)
# Этот принцип говорит о том что не желательно переопределять в подклассах функционал родительского класса, а если необходимо его переопределить, то нужно чтобы не нарушалась функциональность.
# Пример:

# <codecell>

class bird():
    def getFlyspeed(self):
        return self.speed
    
class seagull(bird):
    speed=10
    
class eagle(bird):
    speed=20
    
class penguin(bird):
    def getFlyspeed(self):
        return 'я не могу летать'
    
bird1 = seagull()
bird2 = eagle()
bird3 = penguin()
print (bird1.getFlyspeed())
print (bird2.getFlyspeed())
print (bird3.getFlyspeed())

# <rawcell>

# В данном примере мы переопределили в классе penguin метод getFlyspeed. И он вернул неожиданный тип данных - строку, хотя подразумевается, что мы должны вернуть число. Далее при обработке скорости может возникнуть ошибка.
# 
# Принцип разделения интерфейса (Interface segregation)
# Наследуемые классы которые не могут использовать какие-либо методы, не должны иметь доступ к ним.
# Исправим пример из предыдущего определения:

# <codecell>

class bird():
    def get_name(self):
        return self.name
    
class flying_skill():
    def getFlyspeed(self):
        return self.speed
    
class seagull(bird,flying_skill):
    speed=10
    name='seagull'
    
class eagle(bird,flying_skill):
    speed=20
    name='eagle'
    
class penguin(bird):
    name='penguin'

bird1 = seagull()
bird2 = eagle()
bird3 = penguin()    
print (bird1.get_name())
print (bird1.getFlyspeed())
print (bird2.get_name())
print (bird2.getFlyspeed())
print (bird3.get_name())
print (bird3.getFlyspeed())
    

# <rawcell>

# В итоге мы получаем AttributeError т.к у пингвина нет метода getFlyspeed. Так же можно поставить заглушку на метод getFlyspeed
# 
# Принцип инверсии зависимостей (Dependency Invertion)
# Модули должны зависеть от абстракций, а не от деталей. Т.е к примеру у нас есть класс почта, она должна получить посылку. Посылку может доставить почтальон. Если мы привяжем класс почты к классу почтальон, получится что почта очень сильно привязана к классу почтальон. И при добавлении класса курьер, который тоже может доставлять почту, придётся менять код. Нужно использовать абстрактный класс который имеет метод getParcle()
# Вот пример:

# <codecell>

class parcle():
    def __init__(self,_weigth):
        self.weigth=_weigth
    
class postal():
    def get_parcle(self):
        _parcle=parcle(5)
        print ('Knoc knoc')
        return _parcle.weigth
    
class home_post():
    _postal=postal()
    def take_parcle(self):
        print (self._postal.get_parcle())
        
home=home_post()
home.take_parcle()

# <rawcell>

# В данном примере класс home_post жестко привязан к классу postal. Модифицируем программу для того чтобы программа могла работать с разными источниками посылок)

# <codecell>

class parcle():
    def __init__(self,_weigth):
        self.weigth=_weigth
    
class postal():
    def get_parcle(self):
        _parcle=parcle(5)
        print ('Knoc knoc')
        return _parcle.weigth
    
class dog():
    def get_parcle(self):
        _parcle=parcle(2)
        print ('Wof wof')
        return _parcle.weigth
    
class courier():
    def get_parcle(self):
        _parcle=parcle(10)
        print ('Aaaa i\'m bleeding!! Your dog bit me!!')
        return _parcle.weigth
    
class home_post():
    def take_parcle(self,_some_one):
        some_one=_some_one()
        print (some_one.get_parcle())
        
home=home_post()
home.take_parcle(postal)
home.take_parcle(dog)
home.take_parcle(courier)

# <rawcell>

# 
# 3. Что такое инвариант класса? Как его можно использовать, чтобы избежать
# ненужных операторов if?
# Инвариант класса это условие, которое должно выполняться для всех объектов определенного класса во время всего выполнения. С помощью инварианта можно к примеру задать границы массива, для того чтобы позже не делать проверку на выход из границы массива.
# 
# 4. Что произойдет, если докажут равенство P=NP?
# Вопрос о равенстве классов сложности P=NP. Задача состоит в том чтобы решить что быстрее найти решение задачи или проверить истинность решения. ( Я не очень понимаю зачем этот вопрос и не уверен в правильности понимания мной проблемы и сути вопроса.)
# Если вопрос о равенстве решится с положительным результатом, то это будет значить что многие сложные задачи можно будет решать быстрее чем это делается сейчас.
# 
# 5. Для чего используются исключения?
# Исключения используются для того чтобы улавливать и обрабатывать ошибки, при которых дальнейшее выполнение алгоритма было бы невозможно, либо давало непредсказуемый результат.
# Пример использования, при котором выполнение программы не будет остановлено.

# <codecell>

for i in range (-3,3):
    try:
        print (10/i)
    except ZeroDivisionError:
        print ("Деление на 0")

# <rawcell>

# 6. Нужно ли уметь реализовывать структуры данных типа дерева, например,
# самостоятельно?
# Нужно, хотя-бы для того чтобы глубже и точнее понимать как они работают. Вот тут я реализовал алгоритм постройки бинарного дерева с функциями поиска и удаления любой ноды:
# https://github.com/Kit55/Python-test/blob/master/6/6.5%20%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%20%D0%BD%D0%B0%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D1%85.ipynb
# 
# 7. Как можно работать с общими данными в нескольких потоках выполнения? Какие способы синхронизации вы можете назвать?
# Нельзя чтобы данные перезаписывали друг-друга и "лезли без очереди", для правильно работы с несколькими потоками нужно изначально писать алгоритм, предназначенный для использования в несколько потоков. Для управления потоками используют семафоры, мьютексы, критические секции и.т.д
# 
# 8. Что такое race condition и почему он может возникать?
# Состояние гонки и гонка данных возникает из за неправильного построения алгоритма программы. Некоторые функции могут выполняться быстрее чем другие, из за этого происходит "гонка данных". Пример: данные начинают обрабатываться быстрее чем были получены.
# 
# 9. Что такое акторная модель и для чего ее имеет смысл использовать?
# Это модель которая позволяет разделить программу на акторы. Акторы это такие элементы программы которые не зависят друг от друга,
# что позволяет избежать проблем с синхронизацией.

# <rawcell>

# 2. Объектно­ориентированное программирование
# 
# 1. Что такое IoC? Для чего его можно и нужно использовать?
# Inversion of Control (инверсия управления) - абстрактный принцип, суть которого состоит в том чтобы каждый компонент системы был как можно изолированней от других. Данный принцип рассматривается выше в вопросе про Принцип инверсии зависимостей (Dependency Invertion).
# 
# 2. Что такое таблица виртуальных функций?
# Таблица связывающая адреса виртуальных методов объекта. Метод вызывается при обращении к его адресу из таблицы. Объекты 
# наследующиеся от класса имеют схожую таблицу. Вообще нет единой модели как должна реализовываться эта таблица. Разные компиляторы могут её реализовывать по-разному.
# 
# 3. Что такое наследование, основанное на прототипах? Какие языки его используют?
# Сравните преимущества и недостатки наследования, основанного на прототипах, с
# традиционным вариантом, принятым, например, в Java.
# Наследование основанное на прототипах использую для наследования не классы, а объект-прототип, далее происходит клонирование этого
# объекта прототипа.
# Большинство прототип-ориентированных систем основаны на интерпретируемых языках с динамической типизацией.
# Я знаком с 2 прототип-ориентированными языками это Action Script старых версий (1 и 2) и JavaScript. Так же прототип-о
# риентированными языками являются : Actor-Based Concurrent Language, ABCL: ABCL/1, ABCL/R, ABCL/R2, ABCL/c+ ,Agora, Cecil, Cel, Factor, Io, Kevo, Lua, MOON, NewtonScript, Obliq, OpenLaszlo, REBOL, Self, Slate, TADS.
# В отличие от способа определения объектов с использованием классов, прототипные объектные системы поддерживают более прямой метод создания объектов. Например, в JavaScript объект представляет собой простой список свойств. Каждый объект содержит специальную с
# сылку на другой родительский объект или прототип— объект, поведение которого наследуется.
# Объектно-ориентированный язык программирования, основанный на классах, имеет двойственную природу, требующую наличия по меньшей мере двух основополагающих конструкций: классов и объектов. В результате такой двойственности по мере расширения основанного на классах программного обеспечения возникает тенденция к развитию сложных иерархий классов. Как правило, не всегда возможно заранее предсказать все способы последующего использования классов, поэтому для облегчения внесения изменений требуется постоянный рефакторинг подобной иерархии классов.
# Языки, основанные на прототипах, избавляют от необходимости учета такой двойственности и упрощают прямое создание объектов и манипулирование ими. Отсутствие привязки объектов к классам позволяет создавать более слабо связанные системы объектов, помогающие поддерживать модульность и уменьшающие необходимость в рефакторинге.
# 
# 4. Что такое контракт метода? Что в него входит?
# Контракт метода это предусловия, постусловия и инвариант, которые должны выполняться во время выполнения метода. 
# Предусловия, это условия которые необходимы для того чтобы начать выполнение метода.
# Постусловия, это условия которые должны выполняться после завершения работы метода.
# Инвариант это условия коорые должны выполняться во время работы метода, гарантирующие правильную работу метода.
# Отностильно класса предусловия могут быть ослаблены относительно метода.
# 
# 5. Что такое контракт класса? Что в него входит?
# В контракт класса так-же входят предусловия, постусловия и инвариант при соблюдении всех этих условий возможно создание экземпляра 
# класса.
# Программирование по контракту облегчает взаимодействие между модулями программы т.к не нужно проверять валидность входных-выходных параметров т.к вызывающий модуль должен предоствить валидные параметры для вызываемого модуля. В свою очередь вызываемый модуль
# должен возвращать валидные данные, а соблюдение инварианта гарантирует правильную работу всех модулей.

# <rawcell>

# 3. Web
# 
# 1. Опишите различия между GET и POST запросами.
# Get запрос отправляет информацию серверу через url. В этом случае данные передаются публично и url ограничена по объему передаваемой информации.
# Post запрос отправляет серверу файл, пользователь уже не может видеть, что передаётся серверу.
# Примеры get и post запроса:
# get: https://www.google.ru/?gws_rd=ssl#newwindow=1&q=hello+world
# post: http://www.vavilon-kino.ru/script.php
# 
# 2. Что такое cookie? Какие есть ограничение на размер, содержимое и доступ к
# cookie?
# Cookie это данные отправленные сервером и хранящиеся на компьютере-клиенте. 
# Используются для аутентификации пользователя, хранении информации о сессии, хранение настроек пользователя и т.д.
# 
# 3. Чем отличаются механизмы взаимодействия клиента и сервера при помощи AJAX
# и с использованием WebSocket?
# Я не очень понял суть вопроса, но попробую ответить=)
# Ajax это технология при которой возможно не перегружать страницу полностью, а получать изменения только той части страницы которая была изменена.
# WebSocket это протокол для обмена данными между браузером и сервером. При создании WebSockert (при условии что сервер поддерживает этот протокол) открывается соеденение, в котором можно начинать двунаправленный обмен сообщениями. 
# По сравнению с Ajax в WebSocket не нужно на каждое действие передавать заголовки, особенно это актуальное если общение с сервером состоит из передачи многих небольших блоков данных.
# 
# 4. Как вы понимаете термин UX (User eXperience)? Чем он отличается от UI (User
# Interface)?
# Введём термин продукт - это будет сайт\программа в общем что-то что мы разрабатываем.
# UI - это дизайн, то как продукт выглядит, насколько удобно с ним взаимодействовать.
# UX - это обобщённое ощущение от работы с продуктом, насколько он хорошо работает\насколько с ним удобно работать.
# Примеры:
# Красивый дизайн, но с продуктом сложно работать (Хороший ui плохой ux)
# Невзрачный дизайн, но продукт работает хорошо (Плохой ui хороший ux)
# Продукт может и не иметь ui, к примеру консольное приложение.

# <rawcell>

# 4. Persistance
# 
# 1. Зачем нужны транзакции? Расшифруйте аббревиатуру ACID. Как вы понимаете
# каждую составляющую?
# Транзакция - последовательность операций, переводящих базу данных из одного целостного состояния в другое. Транзакция должна быть выполнена полностью либо не выполнена вообще.
# ACID - это требований к системе, которая управляет базой данных для обеспечения надёжность и предсказуемости её работы.
# Atomicity — Атомарность - гарантирует, что для каждой транзакции будут выполнены все операции, либо не выполнены вообще. Если не все операции транзакции были выполнены, то случится "откат"- возвращение бд к состоянию до начала транзакции.
# Consistency — Согласованность - транзакция после завершения своего выполнения должна сохранять согласованность базы данных.
# Т.е если мы с 1 склада переносим 5 мешков во 2 склад, в 1 должно стать на 5 мешков меньше, а во 2 на 5 мешков больше.
# Isolation — Изолированность - во время выполнения транзакции, параллельно выполняющиеся транзакции не должны иметь влияние друг на друга.
# Durability — Долговечность - сбои бд не должны иметь влияние на завершенные транзакции.
# 
# 2. Какие бываю уровни изоляции транзакций? Как можно добиться согласованного
# изменения данных несколькими пользователями?
# Уровни транзакции используются для предотвращения появления в бд несогласованных данных, которые могут возникнуть при одновременном изменении бд разными пользователями.
# Read uncommitted (чтение незафиксированных данных)
# Это низший уровень изоляции. Блокировка данных на время выполнения команды изменения, изменения запущенные параллельно фактически выполняются последовательно. Команды использующие только чтение не блокируются.
# При этом способе возможно считывание как ещё не зафиксированных данных.
# Read committed (чтение фиксированных данных)
# Защита от "грязного чтения" - тех данных которые не зафиксированы, и в последствии могут откатиться, но в процессе работы одна транзакция может быть завершена, но запущенная ранее транзакция может выполниться с неверным набором данных.
# Repeatable read (повторяемость чтения)
# Уровень при котором никакая другая транзакция не может изменять данные читаемые текущей транзакцией пока она не окончена, однако другие транзакции могут вставлять новые строки, что может привести к фантомному чтению.
# Serializable (упорядочиваемость)
# Во время работы все транзакции полностью изолируют друг-друга. Самый высокий уровень изоляции при котором существенно снижается скорость работы СУБД.
# При проектировке бд нужно учитывать как будут взаимодействовать между собой транзакции запущенные разными клиентами и выставлять уровни изоляции в соответствии с потребностями транзакции.
# 
# 3. Расшифруйте аббревиатуру CRUD. Какие ключевые слова в SQL используются
# для описания функционала соответствующему каждому пункту данного
# определения?
# Create, Read, Update, Delete — «создание, чтение, обновление, удаление»
# Создание
# CREATE TABLE table_name(
#    column1 datatype,
#    column2 datatype,
#    column3 datatype,
#    .....
#    columnN datatype,
#    PRIMARY KEY( one or more columns )
# );
# 
# Чтение
# SELECT column_name,column_name
# FROM table_name;
# 
# Обновление
# UPDATE Laptop 
# SET price = price*0.9
# 
# Удаление
# DROP TABLE ProductVendor1 ;
# 
# 4. Что такое ORM? Опишите плюсы и минусы использования ORM для доступа к БД
# Технология связанная с ООП, которая позволяет связать некую структур данных с БД, для дальнейшего использования в программе.
# Плюсы:
# Простота понимания: код для транзакций через ORM будет меньше и читаемее чем стандартные sql запросы.
# Безопасность: т.к мы работает не с sql запросами, будет меньше уязвимостей и мест для sql-инъекций.
# Упрощение отображения результатов выборки: используя ORM мы получаем результаты выборки из бд через view-контейнеры, которые в свою очередь могут фильтровать и отображать только нужную нам информацию.
# Минусы:
# Неоптимальные sql запросы: генерируемые через ORM запросы могут быть в несколько раз объемнее чем этот-же запрос созданный "руками".
# Умение работать с ORM фреймворками: для того чтобы эффективно использоватьь ферймворк, нужно изучить принцип работы с ним, все его особенности и т.д. При использовании разных ЯП требуются разные фреймворки.
# Разное количество кода для разных фреймворков: При использовании разных фреймворков может использоваться существенно разное количетво кода.
# 
# 5. Как вы думаете, в чем основное преимущество NoSQL решений над SQL? А в чем
# недостатки?
# NoSQL убирает все ограничения реляционной модели (недостаточная производительность, трудоёмкое горизонтальное масштабирование, недостаточная производительность в кластере) и облегчает средства хранения и доступа к данным. Такие БД используют неструктурированный подход (создание структуры на лету), тем самым снимая ограничения жестких связей и предлагая различные типы доступа к специфическим данным.
# Недостатки заключаются в слабом ACID, в меньшей надёжности и устойчивост к сбоям.
# NoSQL системы обычно выбирают высокую производительность не в угоду транзакционной семантике, так как её соблюдение вносит дополнительные затраты на обработку.
# В силу специфики, современные NoSQL обязаны выбирать высокую доступность и способность к горизонтальному масштабированию кластера, — получается что система не может обеспечить полную согласованность данных и идёт на некоторые допущения в определении понятия согласованности. 
# 
# 6. Как вы понимаете суть CAP теоремы? Как вы думаете какими из свойств обладает
# социальная сеть Вконтакте в общем случае?
# CAR теорема заклчается в том что в любой реализации распределенных вычислений возможно обеспечить не более 2 из 3 свойств:
# - Согласованность данных Сonsistency
# - Доступность Availability
# - Устойчивость к разделению Partition tolerance
# 
# Согласованность данных и Устойчивость к разделению:
# A и B, видя, что потеряли связь друг с другом и перестают обрабатывать запросы. В этом случае согласованность не нарушится, но будет потеряна доступность.
# 
# Доступность и Устойчивость к разделению:
# Когда связь между A и B восстановится, при синхронизации всплывет конфликт. Согласованность данных потеряна.
# 
# Согласованность данных и Доступность:
# Cистема неустойчива к разделению. Как только произошло разделение — нужно выбрать, Согласованность данных или Доступность.

# <rawcell>

# 5. Практические навыки
# 
# 1. Что такое система контроля версий? Нужно ли использовать ее, если пишешь код
# один?
# Система контроля версий - система которая следит за изменениями в файлах и запоминает их. В любое время можно откатить изменения.
# Я работал с git-репозиториями когда мы делали учебный проект в команде и когда я писал свой большой проект. В 1 случае было удобно работать в команде т.к проект был разбит на множество мелких файлов, которые нужно было коллективно редактировать и чтобы у всех
# были последние версии изменений.
# Когда я работал над своим проектом я разбивал проект на много мелких подзадач и после завершения каждой делал коммиты. В итоге я всегда мог вернуться к любому изменению. Если что-то ломалось можно было быстро откатиться назад.
# 
# 2. Перечислите основные общепринятые рекомендации для названий переменных,
# классов, функций и методов, не зависящие от языка программирования.
# Имена, представляющие типы, должны быть обязательно написаны в смешанном регистре, начиная с верхнего.
# Имена переменных должны быть записаны в смешанном регистре, начиная с нижнего.
# Именованные константы (включая значения перечислений) должны быть записаны в верхнем регистре с нижним подчёркиванием в качестве разделителя.
# Названия методов и функций должны быть глаголами, быть записанными в смешанном регистре и начинаться с нижнего.
# Членам класса с модификатором private следует присваивать суффикс-подчёркивание.
# Все имена следует записывать по-английски.
# Переменные, имеющие большую область видимости, следует называть длинными именами, имеющие небольшую область видимости — короткими.
# Имена объектов не указываются явно, следует избегать указания названий объектов в именах методов.
# Слова get/set должны быть использованы везде, где осуществляется прямой доступ к атрибуту.
# Префикс n следует использовать для представления числа объектов.
# Переменным-итераторам следует давать имена i, j, k и т. д.
# Функциям (методам, возвращающим какие-либо значения) следует давать имена в зависимости от того, что они возвращают, а процедурам — в зависимости от того, что они выполняют (методы void).
# Переменные никогда не должны иметь двойной смысл.
# 3. Что такое самодокументируемый код? Когда имеет смысл писать комментарии в
# коде, а когда нет?
# Самодокументируемый код, это код в котором в названии всех элементов отражается их суть. Т.к если есть класс Cat() и у него есть метод getWeigth(), можно предположить что класс как-то связан с кошками, а метод должен вернуть вес кошки)
# Я считаю что комментарии хотя-бы краткие нужно писать всегда, чтобы через месяц взглянув на свой код можно было быстро вспомнить что он делает, комментарии важны если в вашем коде будет разбираться другой человек.

# <rawcell>

# 6. Тестирование и контроль качества
# 
# 1. Что такое Test case? Кто обычно их составляет?
# Тест кейс - это описание работы программы, которое при запуске может показать правильно ли работает программа. Их пишут разработчики чтобы быстро проверять работу программы при внесении изменения, либо тестировщики которые проверяют, не накосячил ли программист=))
# 
# 2. Что такое регрессионное тестирование?
# Тестирование которое проверяет работу программы после внесения изменения.
# 
# 3. Что такое unit­тестирование? Какие основные требования налагаются на
# реализацию unit­тестов?
# Модульное тестирование, или юнит-тестирование — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.
# 
# 4. Что такое Mock­объекты? Для чего их имеет смысл использовать?
# Mock-объект в объектно-ориентированном программировании — тип объектов, реализующих заданные аспекты моделируемого программного окружения.
# Принцип его работы : если нужно тестировать функцию, то всё, что не относится к ней самой (например, чтение с диска или из сети), можно подменить макетами-пустышками. При этом тестируемые функции не нужно адаптировать для тестов: Mock подменяет объекты в других модулях, даже если код не принимает их в виде параметров.
# 
# 5. Что такое Continuous Integration? Какие инструменты используются для реализации
# этого подхода?
# Непрерывная интеграция - это практика разработки программного обеспечения, которая заключается в выполнении частых автоматизированных сборок проекта для скорейшего выявления и решения интеграционных проблем.
# Суть этого метода в том, что есть некоторая программа CI которая при появлении изменений автоматически загружает, билдит и прогоняет тесты. Если что-то не работает, она оповещает всех об этом. Это сильно упрощает разработку и позволяет исправлять баги в момент их появления.
# Вот некоторые инструменты CruiseControl, CruiseControl.Net, Atlassian Bamboo, Hudson, Microsoft Team Foundation Server, TeamCity.
# 
# 6. Какие уязвимости бывают с веб ­приложениях? Как можно их искать?
# SQL inj — SQL инъекция, выполнение несанкционированных запросов
# XSS/CSRF — внедрение произвольного JS кода/скрипта в страницу. XSS — Cross Site Scripting (первая буква в аббревиатуре «X» чтобы не было путаницы с CSS (стилями). CSRF — выполнение произвольных действий в браузере пользователя
# RFI/LFI — Remote/Local file inclusion. Использование удаленных («извне»)/локальных файлов в своих целях
# DoS — Denial Of Service. «Умный» вывод ресурса из строя (в отличии от DDoS). Данная атака производится при возможности выполнения «долгих» запросов или длительном выполнении кода.
# 
# 7. Что такое DoS­атака? Какие есть способы защиты от нее? Как это связано с
# ботнетами?
# DDos атака это посылка большого количества запросов на сервер, для того чтобы он вышел из строя.
# Защита состоит в том чтобы анализировать входящие запросы, фильтровать ip с которых ведётся атака и пропускать "легальные" запросы. Эффективность защиты зависит от силы DDos атаки.
# Ботнет - компьютерная сеть, состоящая из некоторого количества хостов, с запущенными ботами — автономным программным обеспечением. Чаще всего бот в составе ботнета является программой, скрытно устанавливаемой на устройство жертвы и позволяющей злоумышленнику выполнять некие действия с использованием ресурсов заражённого компьютера. Обычно используются для нелегальной или неодобряемой деятельности — рассылки спама, перебора паролей на удалённой системе, атак на отказ в обслуживании.
# Большой ботнет состоящий из большого количества машин может устроить сильную DDos атаку.

# <rawcell>

# Ответы дал Пинигин Сергей pinigin-s@mail.ru
# Вопросы получил 6 мая в 13:11. Дата дедлайна 8 мая 13:11

