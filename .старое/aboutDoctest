#  1. Utility Functions
#  2. Example & DocTest -- store test cases
#  3. DocTest Parser -- extracts examples from strings
#  4. DocTest Finder -- extracts test cases from objects
#  5. DocTest Runner -- runs test cases
#  6. Test Functions -- convenient wrappers for testing
#  7. Tester Class -- for backwards compatibility
#  8. Unittest Support
#  9. Debugging Support
# 10. Example Usage

Как работает доктест.
Когда программа доходит до 
if __name__ == "__main__":
    import doctest
    doctest.testmod()

Проверяется что сейчас запущен тестируемый мудуль ( у него имя __main__)

запускаестя метод testmod()//для ввода из докстрингов или testfile() для воода из txt

далее

Ищутся строки документации модуля, всех функций, классов и методов. Объекты, импортируемые в модуль не исследуются.
Кроме того, если существует M.__test__ и он “истинен”, то он должен быть словарём, и каждый элемент отображает строковое имя на объект функции, класса или строку. Ищутся строки документации для этих функций и классов, а строки трактуются как строки документации.
У всех найденных классов будет произведён рекурсивный поиск строк документации во вложеных методах и классах.
По умолчанию, каждый раз, когда doctest находит стоки документации, которые надо протестировать, он использует shallow copy глобальных переменных модуля M‘, так что запуск теста не изменяет реальные значения переменных модуля, так что один тест модуля M не может оставить за собой “следы”, котоыре могут случайно привести к выполнению другого теста. Это означает, что примеры могут спокойно использовать любые имена, определённые на верхнем уровне модуля M, и имена, определённые ранее в этой строке документации. Примеры не могут видеть имена, определённые в другом примере (строке документации).

Поверхностная копия создает новый составной объект, и затем (по мере возможности) вставляет в него ссылки на объекты, находящиеся в оригинале.

Для настройки используются опции\флаги

Объекты DocTest
class doctest.DocTest(examples, globs, name, filename, lineno, docstring)[source]
Набор тестов doctest, которые должны быть запущены в одном пространстве имён. Аргументы конструктора используются для инициализации атрибутов с теми же именами.

DocTest определяет следующие атрибуты. Они инициализируются конструктором и не должны изменяться напрямую.

examples
Список объектов Example, содержащих примеры интерактивных сеансов, которые должны быть проверены этим тестом.

globs
Пространство имён (aka globals), в котором должны быть выполнены тесты. Это словарь, отображающий имена на значения. Все изменения, сделанные в этом пространстве имён тестами (например, добавление новых переменных) будут отражены в globs после завершения теста.

name
Строковое имя, идентифицирующее DocTest. Обычно это имя объекта или файла, откуда был извлечён тест.

filename
Имя файла, откуда был извлечён этот DocTest или None, если оно не известно или если DocTest не был получен из файла.

lineno
Номер строки в filename, где начинается DocTest или None, если номер строки не доступен. Отсчёт начинается с 0.

docstring
Строка, из которой был извлечён тест или ‘None’, если строка не доступна, или тест не был получен из строки.

Объекты Example
class doctest.Example(source, want[, exc_msg][, lineno][, indent][, options])[source]
Один интерактивный пример, состоящий из выражения Python и его ожидаемого вывода. Аргументы конструктора используются для инициализации атрибутов с теми же именами.

Example определяет следующие атрибуты. Они инициализируются конструктором и не должны изменяться напрямую.

source
Строка, содержащая исходный код примера. Этот исходный код состоит из одного выражения Python и всегда заканчивается новой строкой. Переход на новую строку конструктор добавляет автоматически.

want
Ожидаемый вывод из исходного кода выполняемого примера (или в stdout, или трассировка в случае исключения). want завершается новой строкой, а если его вообще нет, то строка будет пустой. Конструктор добавляет переход на новую строку при необходимости.

exc_msg
Сообщение об ошибке, генерируемое примером, если он должен вызывать исключение, или None, если оно не ожидается. Сообщение об ошибке сравнивается с возвращаемым значением функции traceback.format_exception_only(). :attr:`exc_msg`завершается новой строкой, а если его вообще нет, то строка будет пустой. Конструктор добавляет переход на новую строку при необходимости.

lineno
Номер строки в строке, содержащей пример, с которой начинается пример. Нумерация идёт с 0.

indent
Отступ примера в содержащей его строке, то есть количество пробелов, которые находятся перед первым приглашением примера.

options
Словарь, отображающий флаги опций на True или False, который используется для переопределения опций по умолчанию лдя этого примера. Все опции, не определённые в этом словаре будут иметь значения по умолчанию (как определно в атрибуте optionflags класса DocTestRunner). По умолчанию, опции не заданы.

Объекты DocTestFinder
class doctest.DocTestFinder([verbose][, parser][, recurse][, exclude_empty])[source]
Класс-оброаботчик, который используется для извлечения DocTest данного объекта из его строк документации и сторк документации вложенных объектов. DocTest может быть извлечён из следующих типов объектов: модули, функции, классы, методы, статические методы, методы класса и свойства.

Не обяхательный аргумент verbose может быть использован для отображения объектов, которые исследуются. По умолчанию - False (без вывода).

Не обязательный аргумент parser определяет объект DocTestParser (или его замену), которая используется для извлечения тестов из строк документации.

Если не обязательный арумент recurse ложный, тогда DocTestFinder.find() будет проверять лишь переданный объект, но не вложенные объекты.

Если не обязательный аргумент exclude_empty ложный, тогда DocTestFinder.find() будет включать тесты для объектов с пустыми строками документации.

New in version 2.4.

DocTestFinder определяет следующие методы:

find(obj[, name][, module][, globs][, extraglobs])[source]
Возвращает список из DocTest, определённые в строках документации *obj*`a или его вложенных объектов.

Не обязательный аргумент name определяет имя объекта; это имя будет использовано для создания имён для возвращаемых DocTest. Если name не определено, то будет использоваться obj.__name__.

Не обязательный параметр module является модулем, который содержит нужный объект. Если модуль не определён или равен None, тогда поисковик тестов попробует автоматически определить нужный модель. Модуль объекта используется...

Как пространство имён по умолчанию, если globs не определён.
Чтобы не дать DocTestFinder извлечь DocTests из объектов, которые импортируются из других модулей. (Объекты, чьи модули отличаются от module, будут проигнорированы.)
Для поиска имени файла, содержащего объект.
Для помощи в поиске номера строки объекта в файле.
Если module равен False, то не предпринимается попытки обнаружить модуль. Это не ясно и используется по большей части для тестирования самого doctest`a: если module равен False или None и при этом не может быть обнаружен автоматически, тогда все объекты, принадлежащие (не существующему) модулю, так что все содержащиеся объекты (рекурсивно) будут исследованны в поисках тестов.

Глобальные переменные для каждого DocTest образовываются из соединения globs и extraglobs (определения из extraglobs переписывают определения из globs). Для каждого DocTest создаётся своя поверхностная копия. Если globs не определено, тогда его значения равны __dict__*`у модуля, если он определён, или ``{}`` в противном случае. Если *extraglobs не определён, вместо него используется {}.

Объекты DocTestParser
class doctest.DocTestParser[source]
Класс-обработчик, используемый для извлечения интерактивных примеров из строки и использует их для создания объектов DocTest.

New in version 2.4.

DocTestParser определяет следующие методы:

get_doctest(string, globs, name, filename, lineno)[source]
Извлекает все тесты из заданной строки и собирает их в объект DocTest.

globs, name, filename и lineno являются атрибутами для нового объекта DocTest. Смотрите документацию для DocTest.

get_examples(string[, name])[source]
Извлекает все тесты из заданой строки и возвращает их как список объектов Example. Номера строк начинаются с 0. Не обязательный аргумент name является именем, идентифицирующим строку и он используется только для сообщений об ошибках.

parse(string[, name])[source]
Делит заданную строку на тесты и текст и возвращает их как список из Example и строк. Номера строк для Example начинаются с 0. Не обязательный аргумент name является именем, идентифицирующим строку и он используется только для сообщений об ошибках.

Объекты DocTestRunner
class doctest.DocTestRunner([checker][, verbose][, optionflags])[source]
Класс-обработчик, используемый для извлечения и верификации интерактивных тестов в DocTest.

Сравнение между ожидаемым выводом и реальным производится при помощи OutputChecker. Это сравнение можно настроить при помощи различных флагов, описанных подробно в разделе Опции/флаги. Если флагов не достаточно, то настроить сравнение можно передав подкласс OutputChecker в конструктор.

То, как выполнитель теста отображает вывод, можно определить двумя способами. Первый - функция для вывода может быть передана в TestRunner.run(); эта функция будет вызвана для строки, которая должна быть отображена. По умолчанию это sys.stdout.write. Если этого не достаточно, то можно настроить вывод при помощи подкласса DocTestRunner, и переопределить его методы report_start(), report_success(), report_unexpected_exception() и report_failure().

Не обязательный именованый аргумент checker определяет объект OutputChecker (или его замену), который должен использоваться для сравнения итогового и ожидаемого вывода теста.

Не обязательный именованый аргумент verbose определяет подробность сообщений DocTestRunner‘а. Если verbose равен True, тогда будет выводиться информация о каждом примере в процессе его выполнения. Если verbose равен False, тогда будут выведены только сообщения об ошибках. Если verbose не определено или None, тогда подробный вывод будет выведен в том и только в том случае, если используется опция командной строки -v.

Не обязательный именованный аргумент optionflags может быть использован для управления того, как исполнитель тестов будет сравнивать реальный вывод и ожидаемым и как будут отображаться ошибки. Более подробно это описано в разделе Опции/флаги.

New in version 2.4.

DocTestParser определяет следующие методы:

report_start(out, test, example)[source]
Сообщает, что исполнитель тестов готов выполнить данный пример. Этот метод предоставлен чтобы позволить подклассам DocTestRunner настроить свой вывод. Он не должен вызываться напрямую.

example - пример, который должен быть обработан. test - тест, содержащий example. out - функция вывода информации, которая будет передана в DocTestRunner.run().

report_success(out, test, example, got)[source]
Сообщает, что данный пример был успешно выполнен. Этот метод предоставлен чтобы позволить подклассам DocTestRunner настроить свой вывод. Он не должен вызываться напрямую.

example - пример, который должен быть обработан. got - реальный вывод примера. test - тест, содержащий example. out - функция вывода информации, которая будет передана в DocTestRunner.run().

report_failure(out, test, example, got)[source]
Сообщает, что данный пример был провален. Этот метод предоставлен чтобы позволить подклассам DocTestRunner настроить свой вывод. Он не должен вызываться напрямую.

example - пример, который должен быть обработан. got - реальный вывод примера. test - тест, содержащий example. out - функция вывода информации, которая будет передана в DocTestRunner.run().

report_unexpected_exception(out, test, example, exc_info)[source]
Сообщает, что данный пример вызвал неожиданное исключение. Этот метод предоставлен чтобы позволить подклассам DocTestRunner настроить свой вывод. Он не должен вызываться напрямую.

example - пример, который должен быть обработан. exc_info - кортеж, содержащий информацию о неожиданном исключении (как возвращаемый sys.exc_info()). test - тест, содержащий example. out - функция вывода информации, которая будет передана в DocTestRunner.run().

run(test[, compileflags][, out][, clear_globs])[source]
Запускает пример в test (объект DocTest), и отображает результат при помощи “writer” из функции out.

Примеры запускаются в пространстве имён test.globs. Если clear_globs истинен (по умолчанию), тогда пространство имён будет отчищено после выполнения теста, чтобы помочь со сбором мусора. Если Вы захотите проверить пространство имён после выполнения теста, используйте clear_globs=False.

compileflags даёт набор флагов, которые должны использоваться компилятором Python при выполнении примера. Если не определён, то по умолчанию установлены флаги future-import, которые применяются к globs.

Вывод каждого примера проверяется при помощи проверщика вывода из класса DocTestRunner и результат форматируется методами DocTestRunner.report_*().

summarize([verbose])[source]
Выводит итог всех тестов, которые были запущены этим DocTestRunner и возвращает named tuple TestResults(failed, attempted).

Не обязательный аргумент verbose определяет то, насколько детальна будет итоговая информация. Если “подробность” не определена, тогда используется указатель “подробности” из DocTestRunner.

Changed in version 2.6: Добавлен именованый кортеж.

Объекты OutputChecker
class doctest.OutputChecker[source]
Класс, используемый для проверки совпадения реального вывода с ожидаемым. Он определяет два метода: check_output(), который сравнивает полученную пару выводов и возвращает true, если они совпадают; и output_difference(), который возвращает строку, описывающую разницу между двумя выводами.

New in version 2.4.

OutputChecker определяет следующие методы:

check_output(want, got, optionflags)[source]
Возвращает True тогда и только тогда, когда реальный вывод теста (got) совпадает с желаемым (want). Эти строки всегда будут совпадающими, если они идентичны, но в зависимости от флагов исполнителя тестов некоторые не идентичные строки тоже могут рассматриваться как совпавшие. Более подробно это описано в разделе Опции/флаги.

output_difference(example, got, optionflags)[source]
Возвращает строку, описывающую разницу между ожидаемым выводом для примера (example) и реальным выводом (got). optionflags - набор флагов, используемых для сравнения want и got.

Отладка
Doctest предоставляет несколько механизмов для отладки примеров:

Некоторые функции преобразуют doctest`ы в исполняемые программы Python, которые можно запустить в отладчике Python, pdb.

Класс DebugRunner является подклассом DocTestRunner, который возбуждает исключение для первого неудачного примера, содержащий информацию об этом примере. Эта информация может быть использована для “посмертной” отладки примера.

Наборы unittest, создаваемые функцией DocTestSuite() поддреживают метод debug(), определяемый классом unittest.TestCase.

Вы можете добавить вызов функции pdb.set_trace() в примере doctest`а и вы будете “выброшены” в отладчик Python, когда эта строка будет выполнена. После этого вы сможете проверить переменные, и т.д. Например, предположим, что файл a.py содержит только такую строку документации:

"""
>>> def f(x):
...     g(x*2)
>>> def g(x):
...     print x+3
...     import pdb; pdb.set_trace()
>>> f(3)
9
"""
Тогда интерактивная сессия Python может выглядеть так:

>>> import a, doctest
>>> doctest.testmod(a)
--Return--
> <doctest a[1]>(3)g()->None
-> import pdb; pdb.set_trace()
(Pdb) list
  1     def g(x):
  2         print x+3
  3  ->     import pdb; pdb.set_trace()
[EOF]
(Pdb) print x
6
(Pdb) step
--Return--
> <doctest a[0]>(2)f()->None
-> g(x*2)
(Pdb) list
  1     def f(x):
  2  ->     g(x*2)
[EOF]
(Pdb) print x
3
(Pdb) step
--Return--
> <doctest a[2]>(1)?()->None
-> f(3)
(Pdb) cont
(0, 3)
>>>
Changed in version 2.4: Была добавлена возможность использовать pdb.set_trace() внутри doctest`ов.

Фнукции, которые преобразуют doctest`ы в код Python и, возомжно, запускают полученный код в отладчике:

doctest.script_from_examples(s)[source]
Преобразует текст с примером в скрипт.

Аргумент s является строкой, содержащей пример doctest`а. Строка преобразуется в скрипт Python, где примеры в s преобразуются в обычный код, а всё остальное - в комментарии. Полученный скрипт возвращается как строка. Например:

import doctest
print doctest.script_from_examples(r"""
    Set x and y to 1 and 2.
    >>> x, y = 1, 2

    Print their sum:
    >>> print x+y
    3
""")
выведет:

# Set x and y to 1 and 2.
x, y = 1, 2
#
# Print their sum:
print x+y
# Expected:
## 3
Эта функция используется другими функциями модуля (см ниже), но может быть полезна, если вы хотите преобразовать интерактивную сессию Python в скрипт Python.

New in version 2.4.

doctest.testsource(module, name)[source]
Преобразует doctest из объекта в скрипт.

Аргумент module является объектом модуля или именем модуля с точками, содержащим объект, чьи строки документации нас интересуют. Аргумент name - имя (в модуле) объекта, чьи строки документации нам нужны. Результатом является строка, содержащая строки документации объекта, преобразованные в скрипт Python, как это описано выше в функции script_from_examples(). Например, если модуль a.py содержит функцию верхнего уровня f(), тогда:

import a, doctest
print doctest.testsource(a, "a.f")
выведет скрипт для строки документации функции f(), где тест будет преобразован в код, а всё остальное помещено в комментакрии.

New in version 2.3.

doctest.debug(module, name[, pm])[source]
Выполняет отладку doctest`а для объекта.

Аргументы module и name аналогичны для функции testsource(). Полученный скрипт для строк документации нужного объекта записываются во временный файл и затем этот файл запускается под котролем отладчика Python - pdb.

Поверхностная копия module.__dict__ будет использоваться как для локального, так и для глобального контекста исполнения.

Не обязательный аргумент pm определяет, будет ли использоваться “посмертная” отладка. Если pm истинен, тогда скрпит запускается напрямую и отладчик подключается только если скрипт прерывается возбуждением не обрабатываемого исключения. Если это происходит, включается “посмертная” отладка при помощи pdb.post_mortem(), получая объект трассировки из не перехваченного исключения. Если pm не определено или ложно, скрипт запускается с самого начала под отладчиком, передавая соответствующий вызов функции execfile() в pdb.run().

New in version 2.3.

Changed in version 2.4: Был добавлен аргумент pm.

doctest.debug_src(src[, pm][, globs])[source]
Выполняет отладку doctest`а из строки.

Эта функция похожа на debug(), за исключением того, что строка, содержащая примеры определена напрямую, через аргумент src.

Не обязательный аргумент pm имеет то же значение, что и в функции debug().

Не обязательный аргумент globs передаёт словарь, который будет использоваться как локальный и глобальный контекст исполнения. Если он не определён или равен None, используется пустой словарь. Если определено, будет использоваться поверхностная копия словаря.

New in version 2.4.

Класс DebugRunner и специальные исключения, которые он может вызывать, являются наиболее интересными для авторов тестирующих фреймворков, и будут описаны тут лишь вкратце. Смотрите исходный код и в особенности строки документации DebugRunner‘а (которые являются тестами!), где вы найдёте больше информации:

class doctest.DebugRunner([checker][, verbose][, optionflags])[source]
Подкласс DocTestRunner‘а, который возбуждает исключение, как только обнаруживается ошибка. Если возникает неожиданное исключение, возбуждается исключение UnexpectedException, содержащее тест, пример и оригинальное исключение. Если вывод не совпадает, тогда возбуждается исключение DocTestFailure, содержащее тест, пример и реальный вывод.

Информацию о параметрах конструктора и методах можно найти в документации к классу DocTestRunner в разделе Продвинутый API.

Есть два исключения, которые могут быть вызваны экземпляром DebugRunner:

exception doctest.DocTestFailure(test, example, got)[source]
Исключение возбуждается классом DocTestRunner, чтобы сообщить, что реальный вывод примера не соответствует ожидаемому. Аргументы конструктора используются для инициализации атрибутов с тем же именем.

DocTestFailure определяет следующие атрибуты:

DocTestFailure.test
Объект DocTest, который выполнялся, когда провалился пример.

DocTestFailure.example
Example, который был провален.

DocTestFailure.got
Реальный вывод примера.

exception doctest.UnexpectedException(test, example, exc_info)[source]
Исключение, вызываемое DocTestRunner, чтобы сообщить, что пример doctest`а вызвал неожиданное исключение. Аргументы конструктора используются для инициализации атрибутов с тем же именем.

UnexpectedException определяет следующие атрибуты:

UnexpectedException.test
Объект DocTest, который выполнялся, когда пример был провален.

UnexpectedException.example
Example, который был провален.

UnexpectedException.exc_info
Кортеж, содержащий информацию о неожиданном исключении в том виде, как он возвращается функцией sys.exc_info().

Soapbox
Как упоминалось в предисловии, doctest был создан для трёх основных целей:

Проверить примеры в строках документации.
Регрессионного тестирования.
Исполняемой документации / читабельных тестов.
Эти варианты использования имеют различные требования и очень важно их различать. В частности, заполнение ваших строк документации не ясными тестами испортит вашу документацию.

Когда вы пишете строки документации, тщательно выбирайте примеры для них. Это отдельное искуство, которое может быть не очевидно на первый взгляд. Примеры должны добавлять ценности документации. Хорошие примеры могут быть ценее многих слов. Если все сделано внимательно, примеры будут иметь неоценимое значение для пользователей и окупят время, необходимое, чтобы собрать их; особенно с течением времени. Я до сих пор удивляюсь, как часто один из моих примеров doctest перестает работать после «безвредного» изменения.

Doctest так же является замечательным инструментом для регрессионного тестирования, особенно если вы не экономите на пояснительном тексте. Смешивание текста и примеров позволяет гораздо проще отслеживать то, что конкретно тестируется и почему. Когда тест не удаётся, хороший текст позволяет гораздо проще понять, в чём именно проблема и как её исправить. Конечно, вы можете написать исчерпывающие комментарии в код теста, но мало кто так делает. Большинство обнаруживает, что использование docstest’a вместо этого приводит к более понятным тестам. Возможно это просто потому, что doctest позволяет писать текст проще, чем код, так как указывать комментарии в коде теста достаточно тяжело. Я думаю, что на самом деле это глубже: когда вы пишете тесты, вы хотите объяснить суть вашего скрипта и проиллюстрировать его примерами. Это само по себе ведёт к тому, что тестовые файлы начинаются с простых примеров и переходят к более сложным. В результате вы получаете последовательное изложение вместо набора изолированных функций, которые проверяют отдельные куски функционала, что выглядит гораздо менее понятно. Такой подход стирает разницу между тестированием и объяснением.

Регрессионное тестирование лучше всего ограничивается отдельными объектами и файлами. Есть несколько опций для организации тестов:

Написание текстовых файлов, содержащих тесты и примеры, которые тестируют файлы при помощи testfile() или DocFileSuite(). Это рекомендуется, хотя проще это сделать с новым проектом, который с самого начала расчитан на использование doctest.
Определить функции с названием _regrtest_topic, которые содержат одиночные строки документации, содержащие тесты для нужного топика. Эти функции могут находиться в том же файле, что и модуль, или быть вынесены в отдельный тестовый файл.
Определить словарь __test__, отображающий темы регрессионного тестирования на строки документации, содержащие тесты.
Footnotes

[1]	Примеры, содержащие как ожидаемый вывод, так и исключения не поддерживаются. Попытка угадать, где заканчивается одно и начинается другое способствует ошибкам и это делает тесты менее понятными

